"""
Interface Streamlit para PanViTa
Interface web amig√°vel para an√°lise pan-gen√¥mica de virul√™ncia e resist√™ncia
"""

import streamlit as st
import pandas as pd
import os
import sys
from pathlib import Path
import tempfile
from typing import Dict, List, Any
import io
import zipfile
from datetime import datetime

# Adicionar o diret√≥rio parent ao path para importar o core
sys.path.append(str(Path(__file__).parent.parent))

try:
    from core.engine import PanViTaEngine
    from core.processor import GBKProcessor
    from core.downloader import NCBIDownloader
    from core.file_handler import FileHandler
except ImportError:
    st.error("Erro ao importar o engine do PanViTa. Verifique a instala√ß√£o.")
    st.stop()


class PanViTaStreamlitApp:
    """Aplica√ß√£o Streamlit para PanViTa"""
    
    def __init__(self):
        self.engine = PanViTaEngine()
        self.initialize_session_state()
    
    def initialize_session_state(self):
        """Inicializa o estado da sess√£o"""
        if 'analysis_complete' not in st.session_state:
            st.session_state.analysis_complete = False
        if 'results' not in st.session_state:
            st.session_state.results = {}
    
    def run(self):
        """Executa a aplica√ß√£o Streamlit"""
        st.set_page_config(
            page_title="PanViTa - An√°lise Pan-gen√¥mica",
            page_icon="üß¨",
            layout="wide",
            initial_sidebar_state="expanded"
        )
        
        self.render_header()
        self.render_sidebar()
        self.render_main_content()
    
    def render_header(self):
        """Renderiza o cabe√ßalho da aplica√ß√£o"""
        st.title("üß¨ PanViTa - Pan Virulence and Resistance Analysis")
        st.markdown("### An√°lise Pan-gen√¥mica de Virul√™ncia e Resist√™ncia")
        
        col1, col2, col3 = st.columns(3)
        with col1:
            st.info("üìä **An√°lise Comparativa**\nCompare genes de virul√™ncia e resist√™ncia entre cepas")
        with col2:
            st.info("üîç **M√∫ltiplas Databases**\nBacMet, CARD, VFDB, MEGARes")
        with col3:
            st.info("üìà **Visualiza√ß√µes**\nHeatmaps, gr√°ficos e matrizes interativas")
    
    def render_sidebar(self):
        """Renderiza a barra lateral com configura√ß√µes"""
        st.sidebar.header("‚öôÔ∏è Configura√ß√µes")
        
        # Sistema sempre pronto (engine inicializa automaticamente)
        st.sidebar.success("‚úÖ Sistema pronto")
        
        # Configura√ß√µes de an√°lise
        st.sidebar.subheader("üéØ Par√¢metros de An√°lise")
        
        # Databases
        databases = st.sidebar.multiselect(
            "Selecione as databases:",
            ["bacmet", "card", "vfdb", "megares"],
            default=["card", "vfdb"],
            help="Escolha quais databases usar para an√°lise",
            key="databases_selector"
        )
        
        # Thresholds
        identity_threshold = st.sidebar.slider(
            "Threshold de Identidade (%)",
            min_value=0.0,
            max_value=100.0,
            value=70.0,
            step=1.0,
            help="Porcentagem m√≠nima de identidade para considerar um hit",
            key="identity_threshold_slider"
        )
        
        coverage_threshold = st.sidebar.slider(
            "Threshold de Cobertura (%)",
            min_value=0.0,
            max_value=100.0,
            value=70.0,
            step=1.0,
            help="Porcentagem m√≠nima de cobertura da query para considerar um hit",
            key="coverage_threshold_slider"
        )
        
        # Sele√ß√£o de alinhador
        st.sidebar.subheader("üîß Alinhador")
        aligner = st.sidebar.selectbox(
            "Escolha o alinhador:",
            ["diamond", "blast", "both"],
            index=0,  # Diamond como padr√£o
            help="Escolha qual ferramenta de alinhamento usar:\n"
                 "‚Ä¢ DIAMOND: Mais r√°pido, ideal para an√°lises grandes\n"
                 "‚Ä¢ BLAST: Mais sens√≠vel, an√°lise mais detalhada\n"
                 "‚Ä¢ Both: Executa ambos para compara√ß√£o",
            key="aligner_selector"
        )
        
        return {
            'databases': databases,
            'identity_threshold': identity_threshold,
            'coverage_threshold': coverage_threshold,
            'aligner': aligner
        }
    
    def render_main_content(self):
        """Renderiza o conte√∫do principal"""        
        # Tabs principais
        tab1, tab2, tab3, tab4 = st.tabs([
            "üìÅ Upload de Dados", 
            "üî¨ An√°lise", 
            "üìä Resultados", 
            "üìã Logs"
        ])
        
        with tab1:
            self.render_upload_tab()
        
        with tab2:
            self.render_analysis_tab()
        
        with tab3:
            self.render_results_tab()
        
        with tab4:
            self.render_logs_tab()
    
    def render_upload_tab(self):
        """Tab para upload de arquivos"""
        st.header("üìÅ Upload de Dados")
        
        upload_method = st.radio(
            "M√©todo de entrada:",
            ["Upload de arquivos GenBank (.gbff/.gbk)", "Download autom√°tico do NCBI", "Upload de prote√≠nas (.faa)"],
            help="Escolha como fornecer os dados para an√°lise"
        )
        
        if upload_method == "Upload de arquivos GenBank (.gbff/.gbk)":
            self.render_genbank_upload()
        
        elif upload_method == "Download autom√°tico do NCBI":
            self.render_ncbi_download()
        
        elif upload_method == "Upload de prote√≠nas (.faa)":
            self.render_protein_upload()
    
    def render_genbank_upload(self):
        """Upload de arquivos GenBank"""
        st.subheader("Upload de arquivos GenBank")
        
        uploaded_files = st.file_uploader(
            "Selecione arquivos GenBank:",
            type=['gbff', 'gbk', 'gb'],
            accept_multiple_files=True,
            help="Fa√ßa upload dos arquivos GenBank das cepas a serem analisadas"
        )
        
        if uploaded_files:
            st.success(f"‚úÖ {len(uploaded_files)} arquivo(s) carregado(s)")
            
            # Mostrar preview dos arquivos
            with st.expander("üìã Arquivos carregados"):
                for file in uploaded_files:
                    st.write(f"‚Ä¢ {file.name} ({file.size} bytes)")
            
            # Salvar arquivos temporariamente
            if st.button("üíæ Processar arquivos GenBank"):
                with st.spinner("Processando arquivos..."):
                    self.process_genbank_files(uploaded_files)
    
    def render_ncbi_download(self):
        """Download autom√°tico do NCBI"""
        st.subheader("Download autom√°tico do NCBI")
        
        # Upload de arquivo CSV ou input manual
        input_method = st.radio(
            "Como fornecer os IDs das cepas:",
            ["Upload de arquivo CSV", "Input manual"]
        )
        
        if input_method == "Upload de arquivo CSV":
            st.markdown("**üìã Formato do arquivo CSV:**")
            
            # Mostrar exemplo de CSV
            with st.expander("üí° Ver exemplo de formato CSV"):
                exemplo_csv = pd.DataFrame({
                    '#Organism Name': ['Escherichia coli', 'Salmonella enterica'],
                    'Strain': ['K-12', 'LT2'],
                    'GenBank FTP': [
                        'https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/005/825/GCF_000005825.2_ASM582v2',
                        'https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/006/945/GCF_000006945.2_ASM694v2'
                    ],
                    'RefSeq FTP': [
                        'https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/005/825/GCF_000005825.2_ASM582v2',
                        ''
                    ]
                })
                st.dataframe(exemplo_csv)
                
                # Bot√£o para baixar CSV de exemplo
                csv_exemplo = exemplo_csv.to_csv(index=False)
                st.download_button(
                    "‚¨áÔ∏è Baixar CSV de exemplo",
                    csv_exemplo,
                    "exemplo_cepas.csv",
                    "text/csv"
                )
            
            csv_file = st.file_uploader(
                "Upload arquivo CSV com dados das cepas:",
                type=['csv'],
                help="CSV deve conter colunas: '#Organism Name', 'Strain', 'GenBank FTP' (obrigat√≥rias) e opcionalmente 'RefSeq FTP'"
            )
            
            if csv_file:
                df = pd.read_csv(csv_file)
                st.dataframe(df)
                
                if st.button("üåê Baixar do NCBI"):
                    with st.spinner("Baixando arquivos do NCBI..."):
                        self.process_ncbi_download(df)
        
        else:
            st.markdown("**Adicione cepas manualmente:**")
            
            # Formul√°rio para adicionar cepas
            with st.form("add_strain_form"):
                col1, col2 = st.columns(2)
                with col1:
                    organism_name = st.text_input("Nome do organismo:", placeholder="Escherichia coli")
                    genbank_ftp = st.text_input("FTP GenBank:", placeholder="https://ftp.ncbi.nlm.nih.gov/...")
                with col2:
                    refseq_ftp = st.text_input("FTP RefSeq (opcional):", placeholder="https://ftp.ncbi.nlm.nih.gov/...")
                    strain_name = st.text_input("Nome da cepa:", placeholder="K-12")
                
                submit = st.form_submit_button("‚ûï Adicionar cepa")
                
                if submit and organism_name and strain_name:
                    # Validar se pelo menos um FTP foi fornecido
                    if not genbank_ftp and not refseq_ftp:
                        st.error("‚ùå Forne√ßa pelo menos um FTP (GenBank ou RefSeq)")
                    else:
                        # Adicionar √† sess√£o
                        if 'manual_strains' not in st.session_state:
                            st.session_state.manual_strains = []
                        
                        st.session_state.manual_strains.append({
                            '#Organism Name': organism_name,
                            'GenBank FTP': genbank_ftp,
                            'RefSeq FTP': refseq_ftp,
                            'Strain': strain_name
                        })
                        st.success(f"‚úÖ Cepa {strain_name} adicionada!")
            
            # Mostrar cepas adicionadas
            if 'manual_strains' in st.session_state and st.session_state.manual_strains:
                st.subheader("Cepas adicionadas:")
                df_manual = pd.DataFrame(st.session_state.manual_strains)
                st.dataframe(df_manual)
                
                if st.button("üåê Baixar cepas do NCBI"):
                    with st.spinner("Baixando arquivos do NCBI..."):
                        self.process_ncbi_download(df_manual)
    
    def render_protein_upload(self):
        """Upload direto de arquivos de prote√≠nas"""
        st.subheader("Upload de arquivos de prote√≠nas (.faa)")
        
        uploaded_proteins = st.file_uploader(
            "Selecione arquivos de prote√≠nas:",
            type=['faa', 'fa', 'fasta'],
            accept_multiple_files=True,
            help="Fa√ßa upload dos arquivos FASTA com sequ√™ncias de prote√≠nas"
        )
        
        if uploaded_proteins:
            st.success(f"‚úÖ {len(uploaded_proteins)} arquivo(s) de prote√≠nas carregado(s)")
            
            with st.expander("üìã Arquivos de prote√≠nas"):
                for file in uploaded_proteins:
                    st.write(f"‚Ä¢ {file.name} ({file.size} bytes)")
            
            if st.button("üíæ Processar prote√≠nas"):
                with st.spinner("Processando arquivos de prote√≠nas..."):
                    self.process_protein_files(uploaded_proteins)
    
    def render_analysis_tab(self):
        """Tab para executar an√°lise"""
        st.header("üî¨ An√°lise")
        
        if 'processed_files' not in st.session_state:
            st.warning("‚ö†Ô∏è Primeiro fa√ßa upload dos dados na aba 'Upload de Dados'")
            return
        
        # Obter configura√ß√µes da sidebar (j√° renderizada no main)
        config = {
            'databases': st.session_state.get('databases_selector', ['card', 'vfdb']),
            'identity_threshold': st.session_state.get('identity_threshold_slider', 70.0),
            'coverage_threshold': st.session_state.get('coverage_threshold_slider', 70.0),
            'aligner': st.session_state.get('aligner_selector', 'diamond')
        }
        
        st.subheader("Arquivos processados:")
        input_type = st.session_state.get('input_type', 'protein')
        
        if input_type == 'genbank' and 'genbank_files' in st.session_state:
            for name, path in st.session_state.genbank_files.items():
                st.write(f"‚Ä¢ {name}: {os.path.basename(path)} (GenBank)")
        elif input_type == 'protein' and 'protein_files' in st.session_state:
            for name, path in st.session_state.protein_files.items():
                st.write(f"‚Ä¢ {name}: {os.path.basename(path)} (Prote√≠na)")
        else:
            st.warning("‚ö†Ô∏è Nenhum arquivo processado encontrado")
        
        st.subheader("Configura√ß√µes da an√°lise:")
        col1, col2, col3, col4 = st.columns(4)
        with col1:
            st.metric("Databases", len(config['databases']))
        with col2:
            st.metric("Identidade (%)", config['identity_threshold'])
        with col3:
            st.metric("Cobertura (%)", config['coverage_threshold'])
        with col4:
            st.metric("Alinhador", config['aligner'].upper())
        
        # Mostrar informa√ß√µes sobre os arquivos processados
        with st.expander("üîç Informa√ß√µes dos arquivos processados"):
            input_type = st.session_state.get('input_type', 'protein')
            
            if input_type == 'genbank' and 'genbank_files' in st.session_state:
                for name, path in st.session_state.genbank_files.items():
                    if os.path.exists(path):
                        file_size = os.path.getsize(path)
                        st.success(f"‚úÖ {name}: {file_size} bytes (GenBank)")
                    else:
                        st.error(f"‚ùå {name}: Arquivo n√£o encontrado - {path}")
            elif input_type == 'protein' and 'protein_files' in st.session_state:
                for name, path in st.session_state.protein_files.items():
                    if os.path.exists(path):
                        try:
                            with open(path, 'r') as f:
                                content = f.read()
                                protein_count = content.count('>')
                            st.success(f"‚úÖ {name}: {protein_count} prote√≠nas")
                        except Exception as e:
                            st.warning(f"‚ö†Ô∏è {name}: Erro ao ler arquivo - {str(e)}")
                    else:
                        st.error(f"‚ùå {name}: Arquivo n√£o encontrado - {path}")
            else:
                st.warning("‚ö†Ô∏è Nenhum arquivo processado para verificar")
        
        if st.button("üöÄ Iniciar An√°lise", type="primary"):
            if not config['databases']:
                st.error("‚ùå Selecione pelo menos uma database!")
                return
            
            # Verificar se h√° arquivos v√°lidos
            input_type = st.session_state.get('input_type', 'protein')
            if input_type == 'genbank' and 'genbank_files' in st.session_state:
                valid_files = sum(1 for path in st.session_state.genbank_files.values() if os.path.exists(path))
            elif input_type == 'protein' and 'protein_files' in st.session_state:
                valid_files = sum(1 for path in st.session_state.protein_files.values() if os.path.exists(path))
            else:
                valid_files = 0
            
            if valid_files == 0:
                st.error("‚ùå Nenhum arquivo v√°lido encontrado!")
                return
            
            with st.spinner("Executando an√°lise..."):
                self.run_analysis(config)
    
    def render_results_tab(self):
        """Tab para mostrar resultados"""
        st.header("üìä Resultados")
        
        if not st.session_state.analysis_complete:
            st.info("‚ÑπÔ∏è Execute uma an√°lise primeiro para ver os resultados")
            return
        
        results = st.session_state.results
        
        # Resumo geral
        st.subheader("üìà Resumo da An√°lise")
        col1, col2, col3, col4 = st.columns(4)
        
        total_genes = sum(result.get('gene_count', 0) for result in results.values())
        total_strains = max((result.get('strain_count', 0) for result in results.values()), default=0)
        total_files = sum(len(result.get('files', [])) for result in results.values())
        
        with col1:
            st.metric("Total de Genes", total_genes)
        with col2:
            st.metric("Total de Cepas", total_strains)
        with col3:
            st.metric("Databases Analisadas", len(results))
        with col4:
            st.metric("Arquivos Gerados", total_files)
        
        # Resultados por database
        for db_name, result in results.items():
            st.subheader(f"üóÑÔ∏è {db_name.upper()}")
            
            col1, col2 = st.columns(2)
            with col1:
                st.metric(f"Genes encontrados ({db_name})", result.get('gene_count', 0))
            with col2:
                st.metric(f"Cepas analisadas ({db_name})", result.get('strain_count', 0))
            
            # Mostrar matriz se dispon√≠vel
            matrix_file = result.get('matrix_file')
            if matrix_file and os.path.exists(matrix_file):
                with st.expander(f"üìã Matriz de presen√ßa/aus√™ncia - {db_name}"):
                    try:
                        df = pd.read_csv(matrix_file, sep=';')
                        st.dataframe(df, use_container_width=True)
                        
                        # Download da matriz
                        csv = df.to_csv(sep=';', index=False)
                        st.download_button(
                            f"‚¨áÔ∏è Baixar matriz {db_name}",
                            csv,
                            f"matriz_{db_name}.csv",
                            "text/csv"
                        )
                    except Exception as e:
                        st.error(f"Erro ao carregar matriz: {str(e)}")
            
            # Mostrar heatmap se dispon√≠vel
            heatmap_file = result.get('heatmap_file')
            if heatmap_file and os.path.exists(heatmap_file):
                with st.expander(f"üî• Heatmap - {db_name}"):
                    try:
                        st.image(heatmap_file, caption=f"Heatmap {db_name}")
                        
                        # Download do heatmap
                        with open(heatmap_file, "rb") as file:
                            st.download_button(
                                f"‚¨áÔ∏è Baixar heatmap {db_name}",
                                file,
                                f"heatmap_{db_name}.pdf",
                                "application/pdf"
                            )
                    except Exception as e:
                        st.error(f"Erro ao carregar heatmap: {str(e)}")
            
            # Mostrar outros arquivos gerados
            files = result.get('files', [])
            if files:
                with st.expander(f"üìÅ Outros arquivos gerados - {db_name}"):
                    for file_path in files:
                        if os.path.exists(file_path):
                            file_name = os.path.basename(file_path)
                            file_size = os.path.getsize(file_path)
                            
                            col1, col2 = st.columns([3, 1])
                            with col1:
                                st.text(f"üìÑ {file_name} ({file_size} bytes)")
                            with col2:
                                # Bot√£o de download para cada arquivo
                                try:
                                    with open(file_path, "rb") as file:
                                        st.download_button(
                                            "‚¨áÔ∏è",
                                            file,
                                            file_name,
                                            key=f"download_{file_name}_{db_name}"
                                        )
                                except Exception:
                                    st.text("‚ùå")
        
        # Se√ß√£o para download de todos os resultados
        st.subheader("üì¶ Download Completo")
        if st.button("üóÇÔ∏è Preparar ZIP com todos os resultados"):
            self.create_results_zip(results)
    
    def render_logs_tab(self):
        """Tab para mostrar logs e erros"""
        st.header("üìã Logs e Erros")
        
        # Informa√ß√µes do sistema
        st.subheader("üíª Informa√ß√µes do Sistema")
        col1, col2 = st.columns(2)
        
        with col1:
            st.info(f"**Sistema Operacional:** {os.name}")
            st.info(f"**Python:** {sys.version.split()[0]}")
        
        with col2:
            st.info(f"**Diret√≥rio de trabalho:** {os.getcwd()}")
            if 'analysis_temp_dir' in st.session_state:
                st.info(f"**Diret√≥rio da an√°lise:** {st.session_state.analysis_temp_dir}")
        
        # Logs de erro do engine
        col1, col2 = st.columns(2)
        
        with col1:
            st.subheader("‚ùå Erros do Engine")
            if hasattr(self.engine, 'erro') and self.engine.erro:
                for i, error in enumerate(self.engine.erro, 1):
                    st.error(f"{i}. {error}")
            else:
                st.success("‚úÖ Nenhum erro encontrado no engine")
        
        with col2:
            st.subheader("üìÑ Status dos Arquivos")
            if st.session_state.analysis_complete and 'results' in st.session_state:
                results = st.session_state.results
                for db_name, result in results.items():
                    files = result.get('files', [])
                    if files:
                        st.write(f"**{db_name.upper()}:**")
                        for file_path in files:
                            if os.path.exists(file_path):
                                st.success(f"‚úÖ {os.path.basename(file_path)}")
                            else:
                                st.warning(f"‚ö†Ô∏è {os.path.basename(file_path)} (n√£o encontrado)")
                    else:
                        st.info(f"‚ÑπÔ∏è {db_name}: Nenhum arquivo gerado")
            else:
                st.info("‚ÑπÔ∏è Execute uma an√°lise primeiro")
        
        # Informa√ß√µes de debug
        with st.expander("üîß Informa√ß√µes de Debug"):
            st.write("**Session State:**")
            debug_info = {
                'processed_files': st.session_state.get('processed_files', False),
                'analysis_complete': st.session_state.get('analysis_complete', False),
                'protein_files_count': len(st.session_state.get('protein_files', {})),
                'results_count': len(st.session_state.get('results', {}))
            }
            st.json(debug_info)
            
            if st.button("üóëÔ∏è Limpar Session State"):
                keys_to_clear = ['processed_files', 'analysis_complete', 'protein_files', 'results', 'manual_strains']
                for key in keys_to_clear:
                    if key in st.session_state:
                        del st.session_state[key]
                st.success("‚úÖ Session state limpo!")
                st.rerun()
    
    def process_genbank_files(self, uploaded_files):
        """Processa arquivos GenBank carregados"""
        try:
            # Usar diret√≥rio de trabalho atual
            working_dir = os.getcwd()
            gbk_files = []
            
            # Salvar arquivos GenBank no diret√≥rio de trabalho atual
            for uploaded_file in uploaded_files:
                file_path = os.path.join(working_dir, uploaded_file.name)
                with open(file_path, 'wb') as f:
                    f.write(uploaded_file.getbuffer())
                gbk_files.append(file_path)
                st.info(f"üìÅ Arquivo GenBank salvo: {uploaded_file.name}")
            
            # Para arquivos GenBank, vamos armazenar os caminhos dos arquivos .gbff/.gbk
            # O engine vai processar estes arquivos diretamente
            genbank_files = {}
            for gbk_file in gbk_files:
                base_name = os.path.splitext(os.path.basename(gbk_file))[0]
                genbank_files[base_name] = gbk_file
            
            if genbank_files:
                st.session_state.processed_files = True
                st.session_state.genbank_files = genbank_files  # Armazenar arquivos GenBank
                st.session_state.input_type = 'genbank'  # Marcar tipo de entrada
                st.success(f"‚úÖ {len(genbank_files)} arquivo(s) GenBank processado(s) com sucesso!")
                
                # Mostrar preview dos arquivos GenBank
                with st.expander("üìä Arquivos GenBank carregados"):
                    for name, path in genbank_files.items():
                        st.write(f"‚Ä¢ **{name}**: {os.path.basename(path)}")
            else:
                st.error("‚ùå N√£o foi poss√≠vel processar os arquivos GenBank")
            
        except Exception as e:
            st.error(f"‚ùå Erro ao processar arquivos GenBank: {str(e)}")
    
    def process_ncbi_download(self, df):
        """Processa download do NCBI"""
        try:
            # Verificar se as colunas necess√°rias existem
            required_columns = ['#Organism Name', 'Strain', 'GenBank FTP']
            missing_columns = [col for col in required_columns if col not in df.columns]
            
            if missing_columns:
                st.error(f"‚ùå Colunas obrigat√≥rias ausentes no CSV: {', '.join(missing_columns)}")
                st.info("üí° Certifique-se de que o CSV cont√©m as colunas: '#Organism Name', 'Strain', 'GenBank FTP'")
                return
            
            # Converter DataFrame para dicion√°rio no formato esperado pelo NCBIDownloader
            strain_dict = {}
            valid_strains = []
            
            for idx, row in df.iterrows():
                organism_name = row.get('#Organism Name', '')
                strain = row.get('Strain', f'strain_{idx}')
                genbank_ftp = row.get('GenBank FTP', '')
                refseq_ftp = row.get('RefSeq FTP', '')
                
                # Pular linhas sem FTP
                if not genbank_ftp and not refseq_ftp:
                    st.warning(f"‚ö†Ô∏è Cepa {strain} ignorada: sem FTP GenBank ou RefSeq")
                    continue
                
                strain_dict[idx] = (
                    organism_name,
                    genbank_ftp if genbank_ftp else None,
                    refseq_ftp if refseq_ftp else None,
                    strain
                )
                valid_strains.append(strain)
            
            if not strain_dict:
                st.error("‚ùå Nenhuma cepa v√°lida encontrada no CSV")
                return
            
            st.info(f"üì• Iniciando download de {len(strain_dict)} cepa(s)...")
            
            # Usar diret√≥rio de trabalho atual (como na vers√£o CLI)
            working_dir = os.getcwd()
            
            # Inicializar downloader
            downloader = NCBIDownloader(strain_dict)
            
            # Simular sys.argv para o downloader funcionar
            original_argv = sys.argv.copy()
            sys.argv = ["streamlit_app.py", "-b"]  # -b para GenBank files
            
            # Fazer download dos arquivos GenBank
            with st.spinner("Baixando arquivos GenBank do NCBI..."):
                gbff_files = downloader.get_ncbi_gbf()
            
            # Restaurar sys.argv
            sys.argv = original_argv
            
            if gbff_files:
                # Para arquivos baixados do NCBI, vamos armazenar os arquivos GenBank originais
                genbank_files = {}
                progress_bar = st.progress(0)
                
                st.info("üîÑ Processando arquivos baixados...")
                
                for idx, gbff_file in enumerate(gbff_files):
                    if os.path.exists(gbff_file):
                        # Mover arquivo para diret√≥rio de trabalho com nome mais limpo
                        base_name = os.path.splitext(os.path.basename(gbff_file))[0]
                        dest_file = os.path.join(working_dir, f"{base_name}.gbff")
                        
                        try:
                            if os.path.abspath(gbff_file) != os.path.abspath(dest_file):
                                import shutil
                                shutil.move(gbff_file, dest_file)
                            
                            genbank_files[base_name] = dest_file
                            st.success(f"‚úÖ {base_name}: Arquivo GenBank processado")
                            
                        except Exception as e:
                            st.error(f"‚ùå Erro ao processar {os.path.basename(gbff_file)}: {str(e)}")
                            continue
                    
                    # Atualizar barra de progresso
                    progress = (idx + 1) / len(gbff_files)
                    progress_bar.progress(progress)
                
                progress_bar.empty()
                
                if genbank_files:
                    st.session_state.processed_files = True
                    st.session_state.genbank_files = genbank_files  # Armazenar arquivos GenBank
                    st.session_state.input_type = 'genbank'  # Marcar tipo de entrada
                    
                    st.success(f"‚úÖ {len(genbank_files)} cepa(s) processada(s) com sucesso!")
                    
                    # Mostrar resumo
                    with st.expander("üìä Resumo dos downloads"):
                        col1, col2 = st.columns(2)
                        with col1:
                            st.metric("Cepas baixadas", len(gbff_files))
                            st.metric("Arquivos GenBank", len(genbank_files))
                        with col2:
                            st.write("**Arquivos processados:**")
                            for name in genbank_files.keys():
                                st.write(f"‚Ä¢ {name}.gbff")
                    
                    # Listar erros se houver
                    if downloader.erro:
                        st.warning("‚ö†Ô∏è Alguns erros ocorreram durante o download:")
                        for error in downloader.erro:
                            st.text(error)
                else:
                    st.error("‚ùå N√£o foi poss√≠vel processar os arquivos baixados")
            else:
                st.error("‚ùå Nenhum arquivo foi baixado com sucesso")
                if downloader.erro:
                    st.error("Erros encontrados:")
                    for error in downloader.erro:
                        st.text(error)
        
        except Exception as e:
            st.error(f"‚ùå Erro no download do NCBI: {str(e)}")
            import traceback
            st.error(f"Detalhes: {traceback.format_exc()}")
    
    def process_protein_files(self, uploaded_proteins):
        """Processa arquivos de prote√≠nas carregados"""
        try:
            # Usar diret√≥rio de trabalho atual
            working_dir = os.getcwd()
            protein_files = {}
            
            for uploaded_file in uploaded_proteins:
                # Salvar arquivo no diret√≥rio de trabalho atual
                file_path = os.path.join(working_dir, uploaded_file.name)
                with open(file_path, 'wb') as f:
                    f.write(uploaded_file.getbuffer())
                
                # Nome base sem extens√£o
                base_name = os.path.splitext(uploaded_file.name)[0]
                protein_files[base_name] = file_path
                st.info(f"üìÅ Arquivo de prote√≠na salvo: {uploaded_file.name}")
            
            st.session_state.processed_files = True
            st.session_state.protein_files = protein_files
            st.session_state.input_type = 'protein'  # Marcar tipo de entrada
            
            st.success(f"‚úÖ {len(protein_files)} arquivo(s) de prote√≠nas processado(s)")
            
        except Exception as e:
            st.error(f"‚ùå Erro ao processar prote√≠nas: {str(e)}")
    
    def run_analysis(self, config):
        """Executa a an√°lise completa usando o engine atualizado"""
        try:
            # Salvar o sys.argv original
            original_argv = sys.argv.copy()
            
            # Usar o diret√≥rio de trabalho atual (como a vers√£o CLI)
            working_dir = os.getcwd()
            st.info(f"üóÇÔ∏è Diret√≥rio de trabalho: {working_dir}")
            
            # Determinar tipo de entrada e preparar arquivos
            input_type = st.session_state.get('input_type', 'protein')
            
            if input_type == 'genbank':
                # Para arquivos GenBank, passar os arquivos .gbff/.gbk
                working_files = {}
                if 'genbank_files' in st.session_state:
                    for name, file_path in st.session_state.genbank_files.items():
                        if os.path.exists(file_path):
                            working_files[name] = file_path
                            st.write(f"üìÅ Arquivo GenBank: {name} -> {os.path.basename(file_path)}")
                        else:
                            st.warning(f"‚ö†Ô∏è Arquivo GenBank n√£o encontrado: {file_path}")
                
                if not working_files:
                    st.error("‚ùå Nenhum arquivo GenBank v√°lido encontrado!")
                    return
                
                # Para arquivos GenBank, adicionar os nomes dos arquivos ao sys.argv
                file_args = [os.path.basename(path) for path in working_files.values()]
                st.write(f"üìã Arquivos GenBank a serem processados: {file_args}")
                
            else:
                # Para arquivos de prote√≠na, usar como antes
                working_files = {}
                if 'protein_files' in st.session_state:
                    for protein_name, protein_file in st.session_state.protein_files.items():
                        # Definir caminho de destino no diret√≥rio atual
                        dest_file = os.path.join(working_dir, f"{protein_name}.faa")
                        
                        if os.path.exists(protein_file):
                            # Se o arquivo n√£o est√° no diret√≥rio atual, copiar
                            if os.path.abspath(protein_file) != os.path.abspath(dest_file):
                                import shutil
                                shutil.copy2(protein_file, dest_file)
                                st.write(f"üìÅ Arquivo copiado: {protein_name}.faa -> {dest_file}")
                            else:
                                st.write(f"üìÅ Arquivo j√° no diret√≥rio de trabalho: {protein_name}.faa")
                            
                            working_files[protein_name] = dest_file
                        else:
                            st.warning(f"‚ö†Ô∏è Arquivo de prote√≠na n√£o encontrado: {protein_file}")
                
                if not working_files:
                    st.error("‚ùå Nenhum arquivo de prote√≠na v√°lido encontrado!")
                    return
                
                # Para arquivos de prote√≠na, adicionar apenas os nomes dos arquivos .faa
                file_args = [f"{name}.faa" for name in working_files.keys()]
            
            # Verificar arquivos no diret√≥rio atual
            current_files = os.listdir('.')
            if input_type == 'genbank':
                relevant_files = [f for f in current_files if f.endswith(('.gbff', '.gbk', '.gb'))]
                st.write(f"üîç Arquivos GenBank encontrados no diret√≥rio de trabalho: {relevant_files}")
            else:
                faa_files = [f for f in current_files if f.endswith('.faa')]
                st.write(f"üîç Arquivos .faa encontrados no diret√≥rio de trabalho: {faa_files}")
            
            # Configurar sys.argv para o engine
            new_argv = ["streamlit_app.py"]  # Nome do script
            
            # Adicionar databases selecionadas
            for db in config['databases']:
                new_argv.append(f"-{db}")
            
            # Adicionar thresholds se diferentes do padr√£o
            if config['identity_threshold'] != 70.0:
                new_argv.extend(["-i", str(config['identity_threshold'])])
            if config['coverage_threshold'] != 70.0:
                new_argv.extend(["-c", str(config['coverage_threshold'])])
            
            # Adicionar aligner
            if config.get('aligner') == 'diamond':
                new_argv.append("-diamond")
            elif config.get('aligner') == 'blast':
                new_argv.append("-blast")
            elif config.get('aligner') == 'both':
                new_argv.append("-both")
            
            # Adicionar arquivos de entrada
            new_argv.extend(file_args)
            
            # Debug: mostrar comando que ser√° executado
            st.write(f"üöÄ Comando PanViTa: {' '.join(new_argv)}")
            
            # Substituir sys.argv temporariamente
            sys.argv = new_argv
            
            # Executar o engine
            progress_text = st.empty()
            progress_text.text("üöÄ Inicializando engine PanViTa...")
            
            # Verificar diret√≥rio atual antes da execu√ß√£o
            st.write(f"üìç Diret√≥rio atual antes do engine: {os.getcwd()}")
            st.write(f"üìã Arquivos no diret√≥rio: {os.listdir('.')}")
            
            engine = PanViTaEngine()
            
            progress_text.text("‚öôÔ∏è Executando an√°lise...")
            engine.run()
            
            progress_text.text("üìä Coletando resultados...")
            
            # Verificar diret√≥rio atual ap√≥s a execu√ß√£o
            st.write(f"üìç Diret√≥rio atual ap√≥s o engine: {os.getcwd()}")
            st.write(f"üìã Arquivos gerados no diret√≥rio: {os.listdir('.')}")
            
            # Coletar resultados gerados
            results = {}
            
            # Processar resultados por database
            for db in config['databases']:
                db_results = {
                    'database': db,
                    'gene_count': 0,
                    'strain_count': len(working_files),
                    'files': []
                }
                
                # Procurar arquivos espec√≠ficos da database no diret√≥rio atual
                current_files = os.listdir('.')
                st.write(f"üîç Procurando arquivos para {db} em: {current_files}")
                
                for file in current_files:
                    if file.lower().startswith(db.lower()) and (file.endswith('.csv') or file.endswith('.pdf') or file.endswith('.png')):
                        file_path = os.path.abspath(file)
                        db_results['files'].append(file_path)
                        st.write(f"‚úÖ Arquivo encontrado para {db}: {file}")
                        
                        # Se for arquivo de contagem de genes
                        if 'gene_count' in file.lower() and file.endswith('.csv'):
                            try:
                                df = pd.read_csv(file, sep=';')
                                db_results['gene_count'] = len(df)
                                st.write(f"üìä Gene count para {db}: {len(df)} genes")
                            except Exception as e:
                                st.warning(f"‚ö†Ô∏è Erro ao ler arquivo de contagem {file}: {e}")
                        
                        # Se for matriz de presen√ßa/aus√™ncia
                        elif file.lower() == f"matriz_{db.lower()}.csv" or (file.startswith(f"matriz_{db}") and file.endswith('.csv')):
                            db_results['matrix_file'] = file_path
                            st.write(f"üìã Matriz encontrada para {db}: {file}")
                            # Tentar contar genes da matriz
                            try:
                                df = pd.read_csv(file, sep=';')
                                if 'Strains' in df.columns:
                                    db_results['gene_count'] = len(df.columns) - 1
                                else:
                                    db_results['gene_count'] = len(df.columns)
                                st.write(f"üìä Genes na matriz {db}: {db_results['gene_count']}")
                            except Exception as e:
                                st.warning(f"‚ö†Ô∏è Erro ao ler matriz {file}: {e}")
                        
                        # Se for heatmap
                        elif any(keyword in file.lower() for keyword in ['heatmap', 'clustermap']):
                            db_results['heatmap_file'] = file_path
                            st.write(f"üî• Heatmap encontrado para {db}: {file}")
                
                # Verificar se h√° diret√≥rios de resultados espec√≠ficos
                for item in current_files:
                    if os.path.isdir(item) and db.lower() in item.lower():
                        st.write(f"üìÅ Diret√≥rio encontrado para {db}: {item}")
                        # Procurar arquivos dentro do diret√≥rio
                        try:
                            for subfile in os.listdir(item):
                                subfile_path = os.path.join(item, subfile)
                                if os.path.isfile(subfile_path):
                                    db_results['files'].append(os.path.abspath(subfile_path))
                                    st.write(f"üìÑ Arquivo no subdiret√≥rio: {subfile}")
                        except Exception as e:
                            st.warning(f"‚ö†Ô∏è Erro ao listar diret√≥rio {item}: {e}")
                
                results[db] = db_results
                st.write(f"üìà Resumo {db}: {db_results['gene_count']} genes, {len(db_results['files'])} arquivos")
            
            # Salvar resultados no session state
            st.session_state.results = results
            st.session_state.analysis_complete = True
            st.session_state.analysis_temp_dir = working_dir  # Usar diret√≥rio de trabalho atual
            
            progress_text.empty()
            
            # Verificar se houve erros durante a an√°lise
            if hasattr(engine, 'erro') and engine.erro:
                st.warning("‚ö†Ô∏è A an√°lise foi conclu√≠da, mas alguns erros foram encontrados:")
                for error in engine.erro:
                    st.error(error)
                
                # Se todos os resultados est√£o vazios, considerar como falha
                total_genes = sum(result.get('gene_count', 0) for result in results.values())
                if total_genes == 0:
                    st.error("‚ùå Nenhum gene foi encontrado em nenhuma database. Verifique os dados de entrada.")
                else:
                    st.success("‚úÖ An√°lise conclu√≠da com alguns avisos!")
            else:
                st.success("‚úÖ An√°lise conclu√≠da com sucesso!")
                st.balloons()
            
            # Mostrar resumo r√°pido
            col1, col2, col3 = st.columns(3)
            with col1:
                st.metric("Databases analisadas", len(results))
            with col2:
                total_genes = sum(result.get('gene_count', 0) for result in results.values())
                st.metric("Total de genes encontrados", total_genes)
            with col3:
                total_files = sum(len(result.get('files', [])) for result in results.values())
                st.metric("Arquivos gerados", total_files)
            
        except Exception as e:
            st.error(f"‚ùå Erro na an√°lise: {str(e)}")
            import traceback
            st.error(f"Detalhes: {traceback.format_exc()}")
        finally:
            # Restaurar sys.argv original
            sys.argv = original_argv
            # Manter no diret√≥rio de trabalho atual (n√£o precisa voltar)
    
    def create_results_zip(self, results):
        """Cria um arquivo ZIP com todos os resultados da an√°lise"""
        try:
            # Criar buffer para o ZIP
            zip_buffer = io.BytesIO()
            
            with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
                files_added = 0
                
                for db_name, result in results.items():
                    files = result.get('files', [])
                    
                    for file_path in files:
                        if os.path.exists(file_path):
                            # Adicionar arquivo ao ZIP com caminho relativo
                            arc_name = f"{db_name}/{os.path.basename(file_path)}"
                            zip_file.write(file_path, arc_name)
                            files_added += 1
                
                # Adicionar arquivo de resumo
                summary_content = self.generate_analysis_summary(results)
                zip_file.writestr("resumo_analise.txt", summary_content)
                files_added += 1
            
            zip_buffer.seek(0)
            
            if files_added > 0:
                # Nome do arquivo ZIP com timestamp
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                zip_filename = f"panvita_resultados_{timestamp}.zip"
                
                st.download_button(
                    "‚¨áÔ∏è Baixar todos os resultados (ZIP)",
                    zip_buffer.getvalue(),
                    zip_filename,
                    "application/zip"
                )
                st.success(f"‚úÖ ZIP preparado com {files_added} arquivos!")
            else:
                st.warning("‚ö†Ô∏è Nenhum arquivo encontrado para incluir no ZIP")
                
        except Exception as e:
            st.error(f"‚ùå Erro ao criar ZIP: {str(e)}")
    
    def generate_analysis_summary(self, results):
        """Gera um resumo textual da an√°lise"""
        summary = f"""
RESUMO DA AN√ÅLISE PANVITA
=========================
Data da an√°lise: {datetime.now().strftime("%d/%m/%Y %H:%M:%S")}

CONFIGURA√á√ïES:
- Databases analisadas: {', '.join(results.keys())}
- N√∫mero de cepas: {max((result.get('strain_count', 0) for result in results.values()), default=0)}

RESULTADOS POR DATABASE:
"""
        
        for db_name, result in results.items():
            summary += f"""
{db_name.upper()}:
- Genes encontrados: {result.get('gene_count', 0)}
- Cepas analisadas: {result.get('strain_count', 0)}
- Arquivos gerados: {len(result.get('files', []))}
"""
        
        summary += f"""

TOTAL GERAL:
- Total de genes encontrados: {sum(result.get('gene_count', 0) for result in results.values())}
- Total de arquivos gerados: {sum(len(result.get('files', [])) for result in results.values())}

---
Gerado por PanViTa Interface Streamlit
"""
        
        return summary


def main():
    """Fun√ß√£o principal da aplica√ß√£o Streamlit"""
    app = PanViTaStreamlitApp()
    app.run()


if __name__ == "__main__":
    main()
